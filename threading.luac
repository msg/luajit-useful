
-- vim: ft=lua

-- This gets sourced in to the main lua state and any created threads with
-- lua state.  It simplifies all the C stack manipulation and threading
-- problems.

-- The threading library creates an internal lua state for managing
-- the resources between all threads.

-- loaded has the module reference
local threading = package.loaded['useful.threading']

local remove	= table.remove

local exec	= threading.exec
local lock	= threading.lock
local unlock	= threading.unlock

local function setup()
	if _G.data then
		return
	end

	local min	= math.min
	local insert	= table.insert
	local remove	= table.remove

	data		= { }
	channels	= { }
	conditions	= { }

	gett = function(t, except, ...)
		local n = select('#', ...)
		for i=1,n-except do
			t = t[select(i, ...)]
		end
		return t, n + 1
	end

	-- `data` is a global table
	set_locked = function(...)
		local t, n = gett(data, 2, ...)
		t[select(n-2, ...)] = select(n-1, ...)
	end

	get_locked = function(...)
		local results = { pcall(gett, data, 1, ...) }
		if table.remove(results, 1) == false then
			return nil
		end
		local t, n = unpack(results)
		return t[select(n-1, ...)]
	end

	channel_locked = function(name)
		local channel = channels[name] or { queue = { } }
		channels[name] = channel
		return channel
	end

	enqueue_locked = function(name, ...)
		local channel = channel_locked(name)
		insert(channel.queue, {...})
	end

	dequeue_locked = function(name, max)
		local channel = channel_locked(name)
		local results = { }
		local n = min(max or 1, #channel.queue)
		for i=1,n do
			insert(results, remove(channel.queue, 1))
		end
		return results
	end

	queues_locked = function()
		local queues = {}
		for name,_ in pairs(channels) do
			table.insert(queues, name)
		end
		return queues
	end

	flush_locked = function(name)
		channels[name] = nil
	end
end
lock()
exec(setup)
unlock()

local run = function(code, ...)
	lock()
	local result = { pcall(exec, code, ...) }
	unlock()
	if not remove(result, 1) then
		error(result[1])
	end
	return unpack(result)
end

local wrap = function(code)
	return function(...) return run(code, ...) end
end

threading.set		= wrap(function(...) return set_locked(...) end)
threading.get		= wrap(function(...) return get_locked(...) end)
threading.queues	= wrap(function(...) return queues_locked(...) end)
threading.flush		= wrap(function(...) return flush_locked(...) end)
threading.run		= run

local wait	= threading.wait
local signal	= threading.signal

threading.send = function(name, ...)
	lock()
	exec(function(name, ...)
		enqueue_locked(name, ...)
	end, name, ...)
	signal(name)
	unlock()
end

threading.receive = function(name, timeout, max)
	lock()
	max = max or 1
	local size = exec(function(name)
		return #channel_locked(name).queue
	end, name)
	if size == 0 then
		wait(name, timeout)
	end
	local result = exec(function(name, max)
		return dequeue_locked(name, max)
	end, name, max)
	unlock()
	return result
end

